# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, Quarkslab
# This file is distributed under the same license as the tritondse package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: tritondse \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-01-21 22:38+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.0\n"

#: ../../dev_doc/coverage.rst:2
msgid "Coverage"
msgstr "Couverture"

#: of tritondse.coverage.BranchCheckStrategy:1
#: tritondse.coverage.CoverageStrategy:1
msgid "Bases: :class:`enum.IntEnum`"
msgstr ""

#: of tritondse.coverage.BranchCheckStrategy:1
msgid ""
"Branch strategy enumerate. It defines the manner with which branches are "
"checked with SMT on a single trace, namely a :py:obj:`CoverageSingleRun`."
" For a given branch that has not been covered strategies are:"
msgstr ""
"Enum de stratégie de branche. Il définit la manière dont les branches vont être résolues "
"par SMT sur une seule trace d'exécution, c'est à dire dans un :py:obj:`CoverageSingleRun`."
"Pour une branche donnée qui n'a pas été couverte les stratégies sont:"

#: of tritondse.coverage.BranchCheckStrategy:6
msgid "``ALL_NOT_COVERED``: check by SMT all occurences"
msgstr "``ALL_NOT_COVERED``: vérifie par SMT toutes les occurrences"

#: of tritondse.coverage.BranchCheckStrategy:7
msgid ""
"``FIRST_LAST_NOT_COVERED``: check only the first and last occurence in "
"the trace"
msgstr "``FIRST_LAST_NOT_COVERED``: vérifie la première et la dernière occurrence dans la trace"

#: of tritondse.coverage.CovItem:1
msgid "Variant type representing a coverage item. It can be:"
msgstr "Type variant représentant un artefact à couvrir. C'est soit: "

#: of tritondse.coverage.CovItem:4
msgid "an address :py:obj:`tritondse.types.Addr` for block coverage"
msgstr "une adresse :py:obj:`tritondse.types.Addr` pour de la couverture de bloc"

#: of tritondse.coverage.CovItem:5
msgid "an edge :py:obj:`tritondse.types.Edge` for edge coverage"
msgstr "une arête :py:obj:`tritondse.types.Edge` pour de la couverture d'arêtes"

#: of tritondse.coverage.CovItem:6
msgid "a string :py:obj:`tritondse.types.PathHash` for path coverage"
msgstr "une chaîne de caractères :py:obj:`tritondse.types.PathHash` pour de la couverture de chemins"

#: of tritondse.coverage.CoverageSingleRun:1
msgid "Bases: :class:`object`"
msgstr ""

#: of tritondse.coverage.CoverageSingleRun:1
msgid ""
"Coverage produced by a **Single Execution** Depending on the strategy "
"given to the constructor it stores different data."
msgstr ""
"Couverture produite sur **une seule exécution**. En fonction de la stratégie fournie au constructeur, "
"elle emmagasine différents artefacts de couverture (CovItem)."

#: of tritondse.coverage.CoverageSingleRun
#: tritondse.coverage.CoverageSingleRun.add_covered_address
#: tritondse.coverage.CoverageSingleRun.add_covered_branch
#: tritondse.coverage.CoverageSingleRun.is_covered
#: tritondse.coverage.CoverageSingleRun.pp_item
#: tritondse.coverage.GlobalCoverage
#: tritondse.coverage.GlobalCoverage.can_improve_coverage
#: tritondse.coverage.GlobalCoverage.iter_new_paths
#: tritondse.coverage.GlobalCoverage.merge
#: tritondse.coverage.GlobalCoverage.new_items_to_cover
msgid "Parameters"
msgstr "Paramètres"

#: of tritondse.coverage.CoverageSingleRun:5
msgid "Strategy to employ"
msgstr "Stratégie à utiliser"

#: of tritondse.coverage.CoverageSingleRun.add_covered_address:1
msgid ""
"Add an instruction address covered. *(Called by "
":py:obj:`SymbolicExecutor` for each instruction executed)*"
msgstr ""
"Ajoute l'adresse d'une instruction couverte. *(Appelée par "
":py:obj:`SymbolicExecutor` pour chaque instruction exécutées)*"

#: of tritondse.coverage.CoverageSingleRun.add_covered_address:5
msgid "The address of the instruction"
msgstr "Adresse de l'instruction"

#: of tritondse.coverage.CoverageSingleRun.add_covered_branch:1
msgid ""
"Add a branch to our covered branches list. Each branch is encoded "
"according to the coverage strategy. For code coverage, the branch "
"encoding is the address of the instruction. For edge coverage, the branch"
" encoding is the tupe (src address, dst address). For path coverage, the "
"branch encoding is the MD5 of the conjunction of all taken branch "
"addresses."
msgstr ""
"Ajoute une branche couvertes. C'est cette fonction qui met à jour la couverture. "
"Selon la stratégie, la branche est utilisée différemment. Pour de la couverture de blocs, "
"seul l'adresse de l'instruction est conservée. Pour de la couverture d'arête, le tuple "
"adresse source et adresse destination sont conservés. Enfin, pour de la couverture de chemin, "
"l'arête est ajoutée aux précédentes déjà rencontrée puis hashé en MD5 pour encoder le chemin."

#: of tritondse.coverage.CoverageSingleRun.add_covered_branch:7
msgid "The address taken in by the branch"
msgstr "Adresse prise dans le branchement"

#: of tritondse.coverage.CoverageSingleRun.add_covered_branch:9
msgid "Information of the branch condition and its constraints"
msgstr "Information de la condition de branchements et ses contraintes"

#: ../../docstring of tritondse.coverage.CoverageSingleRun.current_path:1
#: tritondse.coverage.GlobalCoverage.current_path:1
msgid "List of addresses forming the path currently being taken"
msgstr "Liste des adresses encodant le chemin emprunté"

#: ../../docstring of tritondse.coverage.CoverageSingleRun.edges:1
#: tritondse.coverage.GlobalCoverage.edges:1
msgid "Edge coverage counter in case of edge coverage"
msgstr "Compteur d'arêtes dans le cas du couverture d'arêtes"

#: ../../docstring of tritondse.coverage.CoverageSingleRun.instructions:1
#: tritondse.coverage.GlobalCoverage.instructions:1
msgid "Instruction coverage. Counter for code coverage)"
msgstr "Couverture d'instructions. (Compteur si couverture de code)."

#: of tritondse.coverage.CoverageSingleRun.is_covered:1
msgid ""
"Return whether the item has been covered or not. **The item should match "
"the strategy**"
msgstr "Renvoie vrai si l'item (artefact) a été couvert ou non. **L'item doit être "
"compatible avec la stratégie courante. "

#: of tritondse.coverage.CoverageSingleRun.is_covered:4
#: tritondse.coverage.CoverageSingleRun.pp_item:3
msgid "An address, an edge or a path"
msgstr "Une adresse, une arête ou un chemin"

#: of tritondse.coverage.CoverageSingleRun.is_covered
#: tritondse.coverage.CoverageSingleRun.pp_item
#: tritondse.coverage.CoverageSingleRun.total_instruction_executed
#: tritondse.coverage.CoverageSingleRun.unique_edge_covered
#: tritondse.coverage.CoverageSingleRun.unique_instruction_covered
#: tritondse.coverage.GlobalCoverage.can_improve_coverage
#: tritondse.coverage.GlobalCoverage.iter_new_paths
#: tritondse.coverage.GlobalCoverage.new_items_to_cover
#: tritondse.coverage.GlobalCoverage.total_instruction_executed
#: tritondse.coverage.GlobalCoverage.unique_edge_covered
#: tritondse.coverage.GlobalCoverage.unique_instruction_covered
msgid "Returns"
msgstr "Renvoie"

#: of tritondse.coverage.CoverageSingleRun.is_covered:6
#: tritondse.coverage.GlobalCoverage.can_improve_coverage:5
msgid "bool"
msgstr "bool"

#: ../../docstring of tritondse.coverage.CoverageSingleRun.not_edges:1
msgid "Edges not covered by the trace. Thus coverage objectives."
msgstr "Arêtes non couvertes dans une trace. Par conséquent les objectifs de couverture"

#: ../../docstring of tritondse.coverage.CoverageSingleRun.not_instructions:1
#: tritondse.coverage.GlobalCoverage.not_instructions:1
msgid ""
"Instruction not covered in the trace (targets of branching conditions "
"never taken). It represent what can be covered by the trace (input), with"
" the branches were negated. We call it coverage objectives."
msgstr ""
"Instructions non couvertes dans la trace *(cible d'une condition de branchement "
"jamais prise). Elles représente ce qui pourrait être couvert par l'entrée si "
"les branches peuvent être niées. Ce sont des objectifs de couverture."

#: ../../docstring of tritondse.coverage.CoverageSingleRun.not_paths:1
msgid "Paths not taken by the trace. Thus coverage objectives."
msgstr "Chemins non pris par la trace."

#: ../../docstring of tritondse.coverage.CoverageSingleRun.paths:1
#: tritondse.coverage.GlobalCoverage.paths:1
msgid ""
"Path covered by the trace. It uses the path predicate. Thus solely "
"symbolic branches are used to compute paths."
msgstr ""
"Chemins couverts par la trace. Utilise le prédicat de chemin, donc seules "
"les branches symboliques sont utilisées pour calculer le chemin."

#: of tritondse.coverage.CoverageSingleRun.post_execution:1
msgid ""
"Function is called after each execution for post processing or clean-up. "
"*(Not doing anythin at the moment)*"
msgstr ""
"Fonction appelée après chaque exécution pour effectuer un post-traitement ou "
"du nettoyage. *(ne fait rien pour le moment)*"

#: of tritondse.coverage.CoverageSingleRun.pp_item:1
msgid "Pretty print a CovItem according the coverage strategy"
msgstr "Affiche un :py:obj:`CovItem`."

#: of tritondse.coverage.CoverageSingleRun.pp_item:4
msgid "str"
msgstr ""

#: ../../docstring of tritondse.coverage.CoverageSingleRun.strategy:1
#: tritondse.coverage.GlobalCoverage.strategy:1
msgid "Coverage strategy"
msgstr "Stratégie de couverture"

#: of tritondse.coverage.CoverageSingleRun.total_instruction_executed:1
#: tritondse.coverage.GlobalCoverage.total_instruction_executed:1
msgid "The number of total instruction executed"
msgstr "Nombre total d'instructions exécutées"

#: of tritondse.coverage.CoverageSingleRun.unique_edge_covered:1
#: tritondse.coverage.GlobalCoverage.unique_edge_covered:1
msgid "The number of unique edges covered"
msgstr "Nombre d'arêtes uniques couvertes"

#: of tritondse.coverage.CoverageSingleRun.unique_instruction_covered:1
#: tritondse.coverage.GlobalCoverage.unique_instruction_covered:1
msgid "The number of unique instructions covered"
msgstr "Nombre d'instructions uniques couvertes"

#: of tritondse.coverage.CoverageStrategy:1
msgid "Coverage strategy enum."
msgstr "Enum de stratégie de couverture"

#: of tritondse.coverage.GlobalCoverage:1
msgid "Bases: :class:`tritondse.coverage.CoverageSingleRun`"
msgstr ""

#: of tritondse.coverage.GlobalCoverage:1
msgid ""
"Global Coverage. Represent the overall coverage of the exploration. It is"
" filled by iteratively call merge with the :py:obj:`CoverageSingleRun` "
"objects created during exploration."
msgstr ""
"Couverture Globale. Représente la couverture accumulée à travers toutes les exécutions. "
"Elle est remplie itérativement à partir de :py:obj:`CoverageSingleRun` combiné à la fonction "
"merge. "

#: of tritondse.coverage.GlobalCoverage:7
msgid "Coverage strategy to use"
msgstr "Stratégie de couverture utilisée"

#: of tritondse.coverage.GlobalCoverage:9
msgid "Execution workspace (for saving loading the coverage)"
msgstr "Espace de travail de l'exécution (pour sauvegarder/charger la couverture)"

#: of tritondse.coverage.GlobalCoverage:11
msgid "Branch checking strategies"
msgstr "Stratégie de branchement"

#: of tritondse.coverage.GlobalCoverage.can_improve_coverage:1
msgid ""
"Check if some of the non-covered are not already in the global coverage "
"Used to know if an input is relevant to keep or not"
msgstr ""
"Vérifie si la couverture d'un :py:obj:`CoverageSingleRun` peut améliorer la couverture "
"globale déjà obtenue. Utilisée pour savoir s'il est pertinent de conserver une entrée ou non."

#: of tritondse.coverage.GlobalCoverage.can_improve_coverage:4
msgid "The CoverageSingleRun to check against our global coverage state"
msgstr "L'objet CoverageSingleRun sur lequel vérifier la couverture"

#: of tritondse.coverage.GlobalCoverage.iter_new_paths:1
msgid ""
"The function iterate the given path predicate and yield PatchConstraint "
"to consider as-is and PathBranch representing the new branch to take. It "
"acts as a black-box so that the SeedManager does not have to know what "
"strategy is being used under the hood. From an implementation perspective"
" the goal of the function is to manipulate the path WITHOUT doing any SMT"
" related things."
msgstr ""
"À partir d'un prédicat de chemin, renvoie sous forme de yield toutes les branches "
"qui représentent de la nouvelle couverture à prendre. Cette fonction, agit en boîte noire "
"pour que le SeedManager n'ait pas à avoir connaissance de la stratégie de couverture employée. "
"D'un point de vue implémentation, le but de la fonction est de manipuler le prédicat "
"de chemin sans effectuer de requêtes SMT."

#: of tritondse.coverage.GlobalCoverage.iter_new_paths:7
msgid "Todo"
msgstr ""

#: of tritondse.coverage.GlobalCoverage.iter_new_paths:7
msgid ""
"Need to implement strategies for a given target returning, all "
"occurences, only the first, only the last etc. At the moment only the "
"first."
msgstr ""
"Nécessite d'implémenter différentes stratégies pour renvoyer toutes les occurrences "
"ou seulement la première/dernière. Pour le moment seul la première est renvoyée."

#: of tritondse.coverage.GlobalCoverage.iter_new_paths:10
msgid "list of path constraint to iterate"
msgstr "liste des contraints de chemin à itérer"

#: of tritondse.coverage.GlobalCoverage.iter_new_paths:11
msgid ""
"generator of path constraint and branches to solve. The first tuple item "
"is a list of PathConstraint to add in the path predicate and the second "
"is the branch to solve (but not to keep in path predicate)"
msgstr ""
"Générateur de contraintes de chemins et de branches à résoudre. Un yield renvoie "
"une liste de contraintes à ajouter à la conjonction et une branche spécifique à nier."

#: of tritondse.coverage.GlobalCoverage.load_coverage:1
msgid "Load the coverage from the workspace"
msgstr "Charge la couverture depuis l'espace de travail"

#: of tritondse.coverage.GlobalCoverage.merge:1
msgid "Merge a CoverageSingeRun instance into this instance"
msgstr "Merge un :py:obj:`CoverageSingleRun` dans cet objet"

#: of tritondse.coverage.GlobalCoverage.merge:3
msgid "The CoverageSingleRun to merge into self"
msgstr "Le CoverageSingleRun à merger dans self"

#: of tritondse.coverage.GlobalCoverage.new_items_to_cover:1
msgid ""
"Return all coverage items (addreses, edges, paths) that the given "
"CoverageSingleRun can cover if it is possible to negate their branches"
msgstr ""
"Renvoie tous les artefacts de couverture qu'un objet :py:obj:`CoverageSingleRun` "
"peux potentiellement couvrir si toutes ses branches peuvent être niées."

#: of tritondse.coverage.GlobalCoverage.new_items_to_cover:4
msgid "The CoverageSingleRun to check with our global coverage state"
msgstr "Le CoverageSingleRun à vérifier sur l'état global (self)"

#: of tritondse.coverage.GlobalCoverage.new_items_to_cover:5
msgid "A set of CovItem"
msgstr "Un Set de CovItem"

#: ../../docstring of tritondse.coverage.GlobalCoverage.pending_coverage:1
msgid ""
"Set of pending coverage items. These are items for which a branch as "
"already been solved and"
msgstr ""
"Ensemble d'artefacts de couverture. Cet ensemble représente tous les CovItem "
"pour lesquels une branche à été résolue avec succès mais dont la couverture n'est "
"pas encore effective car l'entrée associée n'a pas été exécutée."

#: of tritondse.coverage.GlobalCoverage.post_exploration:1
msgid ""
"Function called at the very end of the exploration. It saves the coverage"
" in the workspace."
msgstr ""
"Fonction appelée à la fin de l'exploration. Elle sauvegarde la couverture dans "
"l'espace de travail."

#: of tritondse.coverage.GlobalCoverage.save_coverage:1
msgid "Save the coverage in the workspace"
msgstr "Sauvegarde la couverture dans l'espace de travail."
