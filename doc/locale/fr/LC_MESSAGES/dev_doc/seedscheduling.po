# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, Quarkslab
# This file is distributed under the same license as the tritondse package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: tritondse \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-01-21 22:38+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.0\n"

#: ../../dev_doc/seedscheduling.rst:2
msgid "Seed Scheduling"
msgstr "Ordonancement des Entrées"

#: ../../dev_doc/seedscheduling.rst:4
msgid ""
"Seed scheduling algorithm, are classes basically providing the next seed "
"input to execute. They can be given to the "
":py:obj:`tritondse.seeds_manager.SeedManager` constructor. The scheduling"
" of seeds might be different depending on the need. All strategies should"
" satisfy the interface defined by "
":py:obj:`tritondse.seeds_manager.SeedManager`."
msgstr ""
"L'algorithme d'ordonnancement des graines a pour tâche de fournir la prochaine graine "
"à exécuter. La stratégie est fournie au constructeur de :py:obj:`tritondse.seeds_manager.SeedManager`."
"L'ordonnancement peut être différent en fonction du besoin. Toutes les stratégies "
"doivent satisfaire l'interface définie par: :py:obj:`tritondse.seeds_manager.SeedScheduler`."

#: of tritondse.worklist.SeedScheduler:1
msgid ""
"Abstract class for all seed selection strategies. This class provides the"
" base methods that all subclasses should implement to be compliant with "
"the interface."
msgstr ""
"Classe abstraite représentant une stratégie d'ordonnancement. Cette classe fournit "
"l'interface à implémenter pour satisfaire l'interface."

#: of tritondse.worklist.SeedScheduler.add:1
msgid "Add a new seed in the scheduler"
msgstr "Ajoute une nouvelle graine dans l'ordonnanceur."

#: of tritondse.worklist.FreshSeedPrioritizerWorklist.add
#: tritondse.worklist.SeedScheduler.add
#: tritondse.worklist.SeedScheduler.update_worklist
#: tritondse.worklist.WorklistRand.add
msgid "Parameters"
msgstr "Paramètres"

#: of tritondse.worklist.SeedScheduler.add:3
msgid "Seed to add in the scheduler"
msgstr "Graine à ajouter dans l'ordonnanceur."

#: of tritondse.worklist.SeedScheduler.can_solve_models:1
msgid ""
"Function called by the seed manager to know if it can start negating "
"branches to discover new paths. Some seed scheduler might want to run "
"concretely all inputs first before starting negating branches."
msgstr ""
"Fonction appelée par le SeedManager pour savoir s'il peut nier les branches "
"d'un prédicat de chemin. En effet, certains ordonnanceurs peuvent demander à exécuter "
"toutes les entrées une fois avant de commencer à nier des branches."

#: of tritondse.worklist.FreshSeedPrioritizerWorklist.can_solve_models
#: tritondse.worklist.SeedScheduler.can_solve_models
#: tritondse.worklist.SeedScheduler.has_seed_remaining
#: tritondse.worklist.SeedScheduler.pick
#: tritondse.worklist.WorklistAddressToSet.can_solve_models
#: tritondse.worklist.WorklistAddressToSet.pick
#: tritondse.worklist.WorklistRand.pick
msgid "Returns"
msgstr "Renvoie"

#: of tritondse.worklist.SeedScheduler.can_solve_models:6
msgid "true if the :py:obj:`SeedManager` can negate branches"
msgstr "Vrai si :py:obj:`SeedManager` peut nier les branches"

#: of tritondse.worklist.SeedScheduler.has_seed_remaining:1
msgid "Returns true if there are still seeds to be processed in the scheduler"
msgstr "Renvoie vrai s'il y a toujours des graines en attente de traitement"

#: of tritondse.worklist.SeedScheduler.has_seed_remaining:3
msgid "true if there are seeds to process"
msgstr "vrai si des graines sont à traiter"

#: of tritondse.worklist.SeedScheduler.pick:1
msgid "Return the next seed to execute."
msgstr "Renvoie la prochaine graine à exécuter"

#: of tritondse.worklist.SeedScheduler.pick:3
msgid "seed to execute"
msgstr "graine à exécuter"

#: of tritondse.worklist.SeedScheduler.pick
#: tritondse.worklist.WorklistAddressToSet.pick
#: tritondse.worklist.WorklistRand.pick
msgid "Return type"
msgstr "Type de retour"

#: of tritondse.worklist.SeedScheduler.post_exploration:1
msgid ""
"Called at the end of the exploration to perform some clean-up or anything"
" else."
msgstr "Appelé à la fin de l'exploration pour effectuer du post-traitement ou autre."

#: of tritondse.worklist.SeedScheduler.update_worklist:1
msgid ""
"Call after every execution. That function might help the scheduler with "
"some of its internal states. For instance the scheduler is keep somes "
"seed meant to cover an address which is now covered, it can just drop "
"these seeds."
msgstr ""
"Appelé après chaque exécution. Cette fonction peut aider l'ordonnanceur "
"à effectuer des opérations sur son état interne. Par exemple, l'ordonnanceur "
"peut conserver des graines qui visent à couvrir des adresses qui après l'exécution "
"sont maintenant couvertes. Celles-ci peuvent donc raisonnablement être jetées."

#: of tritondse.worklist.SeedScheduler.update_worklist:6
msgid "global coverage of the exploration"
msgstr "référence vers la couverture globale de l'exploration"

#: ../../dev_doc/seedscheduling.rst:16
msgid "Existing strategies"
msgstr "Stratégies existantes"

#: of tritondse.worklist.FreshSeedPrioritizerWorklist:1
#: tritondse.worklist.WorklistAddressToSet:1 tritondse.worklist.WorklistRand:1
msgid "Bases: :class:`tritondse.worklist.SeedScheduler`"
msgstr ""

#: of tritondse.worklist.FreshSeedPrioritizerWorklist:1
msgid ""
"Strategy that first execute all seeds without negating branches in order to "
"get the most updated coverage and which then re-run all relevant seeds to"
" negate their branches."
msgstr ""
"Stratégie qui exécute d'abord toutes les entrées sans nier de branches pour d'abord obtenir "
"la couverture la plus exhaustive du programme. Elle ré-exécute ensuite chaque graines pouvant "
"mettre à jour de la couverture en niant les branches qui le requiert."

#: of tritondse.worklist.FreshSeedPrioritizerWorklist:9
msgid "This worklist works as follow:"
msgstr "Cette worklist fonctionne comme suit:"

#: of tritondse.worklist.FreshSeedPrioritizerWorklist:6
msgid "return first fresh seeds first to get them executed (to improve coverage)"
msgstr "renvoie une graine 'fraîche' pour qu'elle soit exécutée *(pour améliorer la couverture)*"

#: of tritondse.worklist.FreshSeedPrioritizerWorklist:7
msgid ""
"keep the seed in the worklist up until it gets dropped or thoroughtly "
"processed"
msgstr "garde la graine dans la worklist jusqu'à ce qu'elle soit jetée ou traitée complètement"

#: of tritondse.worklist.FreshSeedPrioritizerWorklist:8
msgid "if no fresh seed is available, iterates seed that will generate coverage"
msgstr "si aucunes graine 'fraîche' n'est disponible, commencer à itérer les autres pour générer la nouvelle couverture."

#: of tritondse.worklist.FreshSeedPrioritizerWorklist.__len__:1
#: tritondse.worklist.WorklistAddressToSet.__len__:1
#: tritondse.worklist.WorklistRand.__len__:1
msgid "Number of pending seeds to execute"
msgstr "Nombre de graines en attente d'être exécutées"

#: of tritondse.worklist.FreshSeedPrioritizerWorklist.add:1
#: tritondse.worklist.WorklistAddressToSet.add:1
#: tritondse.worklist.WorklistRand.add:1
msgid "Add a seed to the worklist"
msgstr "Ajoute une graine dans l'ordonnanceur"

#: of tritondse.worklist.FreshSeedPrioritizerWorklist.add:3
msgid "seed to add to the scheduler"
msgstr "graine à ajouter dans l'ordonnanceur"

#: of tritondse.worklist.FreshSeedPrioritizerWorklist.can_solve_models:1
msgid "Returns True if there are no \"fresh\" seeds to execute."
msgstr "Renvoie vrai s'il n'y a pas de graines \"fraîches\" à exécuter."

#: of tritondse.worklist.FreshSeedPrioritizerWorklist.can_solve_models:3
msgid "True if all fresh seeds have been executed."
msgstr "Vrai si toutes les graines fraîches ont été exécutées"

#: of tritondse.worklist.FreshSeedPrioritizerWorklist.has_seed_remaining:1
#: tritondse.worklist.WorklistAddressToSet.has_seed_remaining:1
#: tritondse.worklist.WorklistRand.has_seed_remaining:1
msgid "Returns true if there are still seeds in the worklist"
msgstr "Renvoie vrai s'il reste des graines à traiter"

#: of tritondse.worklist.FreshSeedPrioritizerWorklist.pick:1
#: tritondse.worklist.WorklistAddressToSet.pick:1
msgid "Return the next seed to execute"
msgstr "Renvoie la prochaine graine à exécuter"

#: of tritondse.worklist.FreshSeedPrioritizerWorklist.post_exploration:1
msgid ""
"At the end of the execution, print the worklist to know its state before "
"exit."
msgstr "À la fin de l'exploration affiche l'état de l'ordonnanceur."

#: of tritondse.worklist.FreshSeedPrioritizerWorklist.update_worklist:1
#: tritondse.worklist.WorklistRand.update_worklist:1
msgid "Update the coverage state of the worklist with the global one"
msgstr "Met à jour la couverture de l'ordonnanceur avec la couverture globale"

#: of tritondse.worklist.WorklistAddressToSet:1
msgid ""
"This worklist classifies seeds by addresses. We map a seed X to an "
"address Y, if the seed X has been generated to reach the address Y. When "
"the method pick() is called, seeds covering a new address 'Y' are "
"selected first. Otherwise anyone is taken."
msgstr ""
"Cet ordonnanceur classifie les graines par adresses (à couvrir). Il assigne "
"une graine X à une adresse Y, si la graine X a été générée pour atteindre Y. "
"Quand la méthode pick est appelé, les graines couvrant Y sont sélectionnées en "
"premières. Autrement n'importe laquelle est prise."

#: of tritondse.worklist.WorklistAddressToSet.can_solve_models:1
msgid ""
"Always true. This strategy always allows solving branches. As a "
"consequence it might try to solve a branch already covered in a seed not "
"run yet. But this enables iterating a seed only once."
msgstr ""
"Toujours vrai. Cette stratégie autorise toujours à résoudre les conditions de branchement. "
"Une conséquence et qu'elle peut tenter de nier une branche couverte dans une autre graine qui "
"n'a pas encore été exécutée. Par contre, cela permet d'exécuter une graine une seule fois."

#: of tritondse.worklist.WorklistAddressToSet.can_solve_models:6
msgid "True"
msgstr "Vrai"

#: of tritondse.worklist.WorklistAddressToSet.pick:3
msgid ""
"next seed to execute (first one covering new addresses, otherwise any "
"other)"
msgstr "prochaine graine à exécuter."

#: of tritondse.worklist.WorklistAddressToSet.post_exploration:1
#: tritondse.worklist.WorklistRand.post_exploration:1
msgid "Does nothing"
msgstr "Ne fais rien"

#: of tritondse.worklist.WorklistAddressToSet.update_worklist:1
msgid "Update the coverage state of the woklist with the global one"
msgstr "Met à jour la couverture de l'ordonnanceur avec la couverture globale"

#: of tritondse.worklist.WorklistRand:1
msgid ""
"Trivial strategy that returns any Seed without any classification. It "
"uses a Set for insertion and pop (which is random) for picking seeds."
msgstr ""
"Stratégie triviale qui renvoie n'importe quelle graine sans aucune classification d'aucune sorte. "
"Elle utilise un set et renvoie n'importe qu'elle élément lors d'une pick."

#: of tritondse.worklist.WorklistRand.add:3
msgid "Seed to add to this rand scheduler"
msgstr "Graine ajoutée à l'ordonnanceur aléatoire"

#: of tritondse.worklist.WorklistRand.can_solve_models:1
msgid "Always true"
msgstr "Toujours vrai"

#: of tritondse.worklist.WorklistRand.pick:1
msgid ""
"Return the next seed to execute. The method pop() removes a random "
"element from the set and returns the removed element. Unlike, a stack a "
"random element is popped off the set."
msgstr ""
"Renvoie la prochaine graine à exécuter. La méthode pop() renvoie un élément "
"aléatoire de l'ensemble et l'enlève par la même occasion de l'ensemble."

#: of tritondse.worklist.WorklistRand.pick:5
msgid "next seed to executre"
msgstr "prochaine graine à exécuter"

