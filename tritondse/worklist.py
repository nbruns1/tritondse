import logging

from tritondse.coverage import GlobalCoverage


class WorklistAddressToSet(object):
    """
    This worklist classifies seeds by addresses. We map a seed X to an
    address Y, if the seed X has been generated to reach the address Y.
    When the method pick() is called, we return a seed which will leads
    to reach new instructions according to the state coverage.
    """
    def __init__(self, config, coverage):
        self.config   = config
        self.coverage = coverage
        self.worklist = dict() # {addr: set(Seed)}


    def __len__(self):
        count = 0
        for k, v in self.worklist.items():
            count += len(v)
        return count


    def add(self, seed):
        if seed.target_addr in self.worklist:
            self.worklist[seed.target_addr].add(seed)
        else:
            self.worklist.update({seed.target_addr: {seed}})


    def pick(self):
        default = None
        to_remove = set()

        for k, v in self.worklist.items():
            # If the set is empty remove the entry
            if not len(v):
                to_remove.add(k)
                continue

            # If the address has never been executed, return the seed
            if k not in self.coverage.instructions:
                default = v.pop()
                if not len(v):
                    to_remove.add(k)
                break

        # If all adresses has been executed, just pick a random seed
        if not default:
            for k, v in self.worklist.items():
                if v:
                    default = v.pop()
                    if not len(v):
                        to_remove.add(k)
                    break

        # Garbage the worklist
        for i in to_remove:
            del self.worklist[i]

        return default



class WorklistRand(object):
    """
    This worklist deals with seeds without any classification. It uses a Set
    for insertion and pop (which is random) for picking seeds.
    """
    def __init__(self, config, coverage):
        self.config   = config
        self.coverage = coverage
        self.worklist = set() # set(Seed)


    def __len__(self):
        return len(self.worklist)


    def add(self, seed):
        self.worklist.add(seed)


    def pick(self):
        """
        The method pop() removes a random element from the set and returns
        the removed element. Unlike, a stack a random element is popped off
        the set.
        """
        return self.worklist.pop()



class FreshSeedPrioritizerWorklist(object):
    """
    This worklist works as follow:
        - return first fresh seeds first to get them executed (to improve coverage)
        - keep the seed in the worklist up until it gets dropped or thoroughtly processed
        - if no fresh seed is available, iterates seed that will generate coverage
    """
    def __init__(self, manager):
        self.manager = manager
        self.fresh = []       # Seed never processed (list to make sure we can pop first one received)
        self.worklist = dict() # CovItem -> set(Seed)

    def __len__(self):
        s = set()
        for seeds in self.worklist.values():
            s.update(seeds)
        return len(self.fresh) + len(s)

    def has_seed_remaining(self):
        return len(self) != 0

    def add(self, seed):
        if seed.coverage_objectives:  # If the seed already have coverage objectives
            for item in seed.coverage_objectives:  # Add it in our worklist
                if item in self.worklist:
                    self.worklist[item].add(seed)
                else:
                    self.worklist[item] = {seed}
            # seed.coverage_objectives.clear()  # Flush the objectives
        else:  # Otherwise it is fresh
            self.fresh.append(seed)

    def update_worklist(self, coverage: GlobalCoverage):
        # Iterate the worklist to see if some items have now been covered
        # and are thus not interesting anymore
        to_remove = [x for x in self.worklist if coverage.is_covered(x)]

        for item in to_remove:
            for seed in self.worklist.pop(item):
                seed.coverage_objectives.remove(item)
                if not seed.coverage_objectives:  # The seed cannot improve the coverage of anything
                    self.manager.drop_seed(seed)

    def can_solve_models(self) -> bool:
        return not self.fresh  # True if the set of fresh seeds is empty

    def pick(self) -> 'Seed':
        """ Return the next seed to execute """
        # Pop first fresh seed
        if self.fresh:
            return self.fresh.pop(0)  # Return first item as it is the older

        # Then pop seed meant to crash
        if ... in self.worklist:  # If we have specific seeds (mostly generated by sanitizers)
            it = self.worklist[...].pop()
            if not self.worklist[...]:  # Remove the key if now empty
                self.worklist.pop(...)
            return it

        # Then pop traditional coverage seeds
        k = list(self.worklist.keys())[0]      # arbitrary covitem
        seed = self.worklist[k].pop()          # remove first seed inside
        for it in seed.coverage_objectives:    # Remove the seed from all worklist[x]
            if it != k:                        # we already popped the item from k
                self.worklist[it].remove(seed) # remove the seed from that covitem set
            if not self.worklist[it]:          # remove the whole covitem if empty
                self.worklist.pop(it)
        return seed

    def post_exploration(self):
        s = " ".join(str(x) for x in self.worklist)
        logging.info(f"Many not covered items: {s}")
        # TODO: Save them in the workspace
